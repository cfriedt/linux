/dts-v1/;

/* compile with:
 * dtc -I dts -O dtb -o discoball.dt{b,s}
 */ 

/*
 * Example from Documentation/pinctrl.txt
 *
 *        A   B   C   D   E   F   G   H
 *      +---+
 *   8  | o | o   o   o   o   o   o   o
 *      |   |
 *   7  | o | o   o   o   o   o   o   o
 *      |   |
 *   6  | o | o   o   o   o   o   o   o
 *      +---+---+
 *   5  | o | o | o   o   o   o   o   o
 *      +---+---+               +---+
 *   4    o   o   o   o   o   o | o | o
 *                              |   |
 *   3    o   o   o   o   o   o | o | o
 *                              |   |
 *   2    o   o   o   o   o   o | o | o
 *      +-------+-------+-------+---+---+
 *   1  | o   o | o   o | o   o | o | o |
 *      +-------+-------+-------+---+---+
 */

/ {
	compatible = "simple-bus";
	#address-cells = <1>;
	#size-cells = <0>;
	
	pinctrl_fake0: pinctrl-fake@0 {

		/*
		 * In contrast to devicetree bindings for concrete pin controller
		 * implementations, this pin controller does not have a hard-
		 * coded set of pins, pin-names, or groups that would typically
		 * be declared statically in the OS kernel. Therefore, for this
		 * fake but configurable pin controller, we define all of those
		 * parameters within the devicetree file so that they can be
		 * dynamically instantiated within the OS kernel at runtime prior
		 * to probing of any fake busses or devices.
		 */
		compatible = "pinctrl-fake";
		#address-cells = <1>;
		#size-cells = <0>;
		reg = <0>;
		#pinctrl-cells = <0>;

		/*
		 * First, we define a set of fake pins and name those pins.
		 */

		pinctrl-fake-pins = <
			 0  8 16 24
			25 38 46 54
			56 57 58 59
			60 61 62 63
		>; 
		pinctrl-fake-pin-names =
			"A8", "A7", "A6", "A5",
			"B5", "G4", "G3", "G2",
			"A1", "B1", "C1", "D1",
			"E1", "F1", "G1", "H1"
		;

		/*
		 * Next, we state that this pin controller will have a fake
		 * gpio chip as well as a fake irq chip.
		 */

/*
		gpio-controller;
		interrupt-controller;
*/
		
		/*
		 * Then, we group pin functionally.
		 */

		pinctrl-fake-pin-groups =
			"spi0_0",
			"spi0_1",
			"i2c0",
			"mmc0_0",
			"mmc0_1",
			"mmc0_2"
		;
		pinctrl-fake-pin-group-0 = <
			0 8 16 24
		>;
		pinctrl-fake-pin-group-1 = <
			38 46 54 62
		>;
		pinctrl-fake-pin-group-2 = <
			24 25
		>;
		pinctrl-fake-pin-group-3 = <
			56 57
		>;
		pinctrl-fake-pin-group-4 = <
			56 57 58 59
		>;
		pinctrl-fake-pin-group-5 = <
			56 57 58 59
			60 61 62 63
		>;

		/*
		 * Then we define pinmux functions.
		 */
		 
		 pinctrl-fake-pin-muxes =
		 	"spi0",
		 	"i2c0",
		 	"mmc0"
		 ;
		 
		 pinctrl-fake-pin-mux-0 =
		 	"spi0_0",
		 	"spi0_1"
		 ;

		 pinctrl-fake-pin-mux-1 =
		 	"i2c0"
		 ;

		 pinctrl-fake-pin-mux-2 =
		 	"mmc0_0",
			"mmc0_1",
			"mmc0_2"
		 ;

		/*
		 * And, lastly, we define state mappings.
		 * This is a 4-tuple of strings:
		 * dev_name, name, group, function 
		 */
		 
		 pinctrl-fake-mappings =
		 	"spi-fake.0", "pos-A", "spi0", "spi0_0",
		 	"spi-fake.0", "pos-B", "spi0", "spi0_1",
		 	"i2c-fake.0", "i2c0", "i2c0", "i2c0",
		 	"mmc-fake.0", "2bit", "mmc0", "mmc0_0",
		 	"mmc-fake.0", "4bit", "mmc0", "mmc0_1",
		 	"mmc-fake.0", "8bit", "mmc0", "mmc0_2"
		 ;

		gpiochip0: gpiochip@0 {
			compatible = "gpio-fake";
			reg = <0>;
		};
	};
};